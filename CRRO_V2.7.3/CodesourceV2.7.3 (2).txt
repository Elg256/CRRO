import tkinter as tk
from tkinter import filedialog, messagebox
import random
import hashlib
from cryptography.fernet import Fernet
import base64
import pyperclip
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import os
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

key_management_window = None
key_access_window = None
nomaff = "none"
cle = 1
key1 = None
cle_visible = False
cle_visible2 = False
type = 1
sign = 2


def generate_aes_key():
    key = os.urandom(32)  # Générer une clé de 256 bits (32 octets)
    backend = default_backend()
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
    encryptor = cipher.encryptor()
    truncated_key = encryptor.update(key) + encryptor.finalize()[:8]  # Tronquer la clé à la longueur appropriée
    return truncated_key


def ouvrir_file():
    global window
    # Vérifier si la deuxième fenêtre est déjà ouverte
    if window is not None and window.winfo_exists():
        window.deiconify()
        return

    def generate_key():
        window.attributes('-topmost', True)

        """
        Génère une nouvelle clé AES
        """
        global key4
        key4 = Fernet.generate_key()
        champ_cle.delete(0, tk.END)
        champ_cle.insert(tk.END, key4)
        return key4

    def encrypt_file():

        """
        Chiffre un fichier en utilisant la clé AES fournie
        """
        file_path = filedialog.askopenfilename(title="Sélectionner le fichier à chiffrer")
        if not file_path:
            return

        output_path_entry = output_entry.get().strip()
        if output_path_entry:
            output_path = output_path_entry
        else:
            output_path = os.path.join(os.path.dirname(__file__),
                                       os.path.splitext(os.path.basename(file_path))[0] + ".enc")
        if os.path.exists(output_path):
            messagebox.showerror("Erreur", "Le fichier de sortie existe déjà.")
            return

        window.attributes('-topmost', True)
        fernet = Fernet(key4)
        with open(file_path, "rb") as file:
            file_data = file.read()
        encrypted_data = fernet.encrypt(file_data)
        with open(output_path, "wb") as encrypted_file:
            encrypted_file.write(encrypted_data)
        messagebox.showinfo("Chiffrement réussi", "Le fichier a été chiffré avec succès.")
        copy_key = messagebox.askyesno("Copier la clé",
                                       "Voulez-vous copier la clé dans le presse-papiers ?\n\nClé : " + key4.decode())
        if copy_key:
            pyperclip.copy(key4.decode())
            window.attributes('-topmost', True)

    def decrypt_file():
        window.attributes('-topmost', True)
        """
        Déchiffre un fichier en demandant la clé AES à l'utilisateur
        """
        file_path = filedialog.askopenfilename(title="Sélectionner le fichier à déchiffrer")
        if not file_path:
            return

        output_path_entry = output_entry.get().strip()
        if output_path_entry:
            output_path = output_path_entry
        else:
            output_path = os.path.join(os.path.dirname(__file__),
                                       os.path.splitext(os.path.basename(file_path))[0] + ".dec")

        if os.path.exists(output_path):
            messagebox.showerror("Erreur", "Le fichier de sortie existe déjà.")
            return

        key_entry_window = tk.Toplevel(window)
        key_entry_window.title("Clé de déchiffrement")
        key_entry_window.geometry("300x180")
        key_entry_window.iconbitmap("logo3RSAl - Copie.ico")
        key_label = tk.Label(key_entry_window, text="Entrez la clé AES pour le déchiffrement: ")
        key_label.pack()
        key_entry = tk.Entry(key_entry_window, show="*")
        key_entry.pack()
        key_entry.focus()
        key_entry_window.attributes('-topmost', True)

        def decrypt_with_key():
            user_key = key_entry.get().encode()
            key_entry_window.destroy()
            try:
                fernet = Fernet(user_key)
                with open(file_path, "rb") as file:
                    encrypted_data = file.read()
                decrypted_data = fernet.decrypt(encrypted_data)
                with open(output_path, "wb") as decrypted_file:
                    decrypted_file.write(decrypted_data)
                messagebox.showinfo("Déchiffrement réussi", "Le fichier a été déchiffré avec succès.")
            except Exception:
                messagebox.showerror("Erreur", "La clé fournie est incorrecte. Le déchiffrement a échoué.")

        decrypt_button = tk.Button(key_entry_window, text="Déchiffrer", command=decrypt_with_key)
        decrypt_button.pack()

    window = tk.Toplevel()
    window.iconbitmap("logo3RSAl - Copie.ico")
    window.title("Programme de chiffrement AES")
    window.geometry("400x250")

    key = None

    output_label = tk.Label(window, text="Chemin de sortie du chiffrement/déchiffrement :")
    output_label.pack()

    output_entry = tk.Entry(window)
    output_entry.pack()

    encrypt_button = tk.Button(window, text="Chiffrer un fichier", command=encrypt_file)
    encrypt_button.pack(pady=10)

    decrypt_button = tk.Button(window, text="Déchiffrer un fichier", command=decrypt_file)
    decrypt_button.pack()

    generate_key_button = tk.Button(window, text="Générer une nouvelle clé", command=lambda: generate_new_key())
    generate_key_button.pack(pady=10)

    cle_label = tk.Label(window, text="Clé AES actuelle:")
    cle_label.pack()

    champ_cle = tk.Entry(window, width=60)
    champ_cle.pack()

    def generate_new_key():
        global key4
        key4 = generate_key()


window = None


def toggle_key_visibility():
    global cle_visible
    cle_visible = not cle_visible
    if cle_visible:
        label_cle.grid(row=0, column=5)
        champ_cle.grid(row=1, column=5, padx=30)
        bouton_generer_cle_aes.grid(row=2, column=5)
    else:
        label_cle.grid_forget()
        champ_cle.grid_forget()
        bouton_generer_cle_aes.grid_forget()


def toggle_key_visibility2():
    global cle_visible2
    cle_visible2 = not cle_visible2
    if cle_visible2:
        label_clepriver.grid(row=0, column=4)
        champ_clepriver.grid(row=1, column=4)

    else:
        label_clepriver.grid_forget()
        champ_clepriver.grid_forget()


def ouvrir_parametres():
    global parametres
    # Vérifier si la deuxième fenêtre est déjà ouverte
    if parametres is not None and parametres.winfo_exists():
        parametres.deiconify()
        return
    parametres = tk.Toplevel(fenetre)
    parametres.iconbitmap("logo3RSAl - Copie.ico")
    parametres.title("Paramètres")
    largeur = 250
    hauteur = 160
    parametres.geometry(f"{largeur}x{hauteur}")

    def choisir_taille(taille):
        if taille == "Très petit":
            champ_message.config(height=1, width=50)
        elif taille == "Petit":
            champ_message.config(height=15, width=100)
        elif taille == "Normal":
            champ_message.config(height=30, width=150)
        elif taille == "Grand":
            champ_message.config(height=35, width=165)

    label_taille = tk.Label(parametres, text="Taille du champ Message :", font=("Helvetica", 12))
    label_taille.pack(pady=5)

    petit_btn = tk.Button(parametres, text="Très petit", command=lambda: choisir_taille("Très petit"))
    petit_btn.pack()

    normal_btn = tk.Button(parametres, text="Petit", command=lambda: choisir_taille("Petit"))
    normal_btn.pack()

    grand_btn = tk.Button(parametres, text="Normal", command=lambda: choisir_taille("Normal"))
    grand_btn.pack()

    grand_btn = tk.Button(parametres, text="Grand", command=lambda: choisir_taille("Grand"))
    grand_btn.pack()


parametres = None


def ouvrir_parametres2():
    global parametres2
    # Vérifier si la deuxième fenêtre est déjà ouverte
    if parametres2 is not None and parametres2.winfo_exists():
        parametres2.deiconify()
        return
    parametres2 = tk.Toplevel(fenetre)
    parametres2.iconbitmap("logo3RSAl - Copie.ico")
    parametres2.title("Paramètres")

    def fenetreferme():
        parametres2.destroy()
        global cle
        cle = 2

    def fenetreferme2():
        parametres2.destroy()
        global cle
        cle = 1

    label_taille = tk.Label(parametres2, text="Type de clé:", font=("Helvetica", 12))
    label_taille.pack(pady=5)
    bouton_access = tk.Button(parametres2, text="Classique", command=fenetreferme2)
    bouton_access.pack()

    bouton_access = tk.Button(parametres2, text="Longue", command=fenetreferme)
    bouton_access.pack()

    if cle == 2:
        label_type_cle = tk.Label(parametres2, text="Actuellement en mode : Longue", font=("Helvetica", 12))
        label_type_cle.pack(pady=7)
    else:
        label_type_cle = tk.Label(parametres2, text="Actuellement en mode : Classique", font=("Helvetica", 12))
        label_type_cle.pack(pady=7)


parametres2 = None


def ajouter_cle():
    nom = entry_nom.get()
    publique = entry_publique.get()
    cle = f"{nom}  \n Clé publique: {publique}\n"
    frame_cle = tk.Frame(frame_cles, bg="white", pady=5)
    frame_cle.pack(fill=tk.X)
    entry_cle = tk.Entry(frame_cle, width=86)
    entry_cle.insert(tk.END, cle)
    entry_cle.pack(side=tk.LEFT, padx=5, pady=5)
    button_copier = tk.Button(frame_cle, text="Utiliser", command=lambda key=publique: copier_cle(key))
    button_copier.pack(side=tk.LEFT, padx=5, pady=5)
    button_supprimer = tk.Button(frame_cle, text="Supprimer",
                                 command=lambda frame=frame_cle, key=publique: confirmer_suppression(frame, key))
    button_supprimer.pack(side=tk.LEFT, padx=5, pady=5)
    enregistrer_cle(nom, publique)


def copier_cle(key):
    champ_clepublique.delete(0, tk.END)
    champ_clepublique.insert(tk.END, key)
    messagebox.showinfo("Accés", "Accés à la clé publique.")


def confirmer_suppression(frame_cle, key):
    deuxieme_fenetre.lift()
    if messagebox.askyesno("Confirmation", "Êtes-vous sûr de vouloir supprimer cette clé publique ?"):
        supprimer_cle(frame_cle, key, fenetre)


def supprimer_cle(frame_cle, key, fenetre_principale):
    frame_cle.destroy()
    supprimer_cle_fichier(key)
    deuxieme_fenetre.lift()


def supprimer_cle_fichier(key):
    with open("registre.txt", "r") as fichier:
        lignes = fichier.readlines()
    with open("registre.txt", "w") as fichier:
        for ligne in lignes:
            if f"Cle publique: {key}" not in ligne:
                fichier.write(ligne)


def enregistrer_cle(nom, publique):
    with open("registre.txt", "a") as fichier:
        fichier.write(f"Nom: {nom} Cle publique: {publique}\n\n")


def charger_registre():
    try:
        with open("registre.txt", "r") as fichier:
            contenu = fichier.readlines()
            for line in contenu:
                if line.startswith("Nom:"):
                    line = line.replace("Nom: ", "")
                    frame_cle = tk.Frame(frame_cles, bg="white", pady=5)
                    frame_cle.pack(fill=tk.X)
                    entry_cle = tk.Entry(frame_cle, width=86)
                    entry_cle.insert(tk.END, line)
                    entry_cle.pack(side=tk.LEFT, padx=5, pady=5)
                    publique = line.split(": ")[-1].strip()
                    button_copier = tk.Button(frame_cle, text="Utiliser", command=lambda key=publique: copier_cle(key))
                    button_copier.pack(side=tk.LEFT, padx=5, pady=5)
                    button_supprimer = tk.Button(frame_cle, text="Supprimer",
                                                 command=lambda frame=frame_cle, key=publique: confirmer_suppression(
                                                     frame, key))
                    button_supprimer.pack(side=tk.LEFT, padx=5, pady=5)
    except FileNotFoundError:
        pass


def ouvrir_deuxieme_fenetre():
    global entry_nom, entry_publique, frame_cles, deuxieme_fenetre
    # Vérifier si la deuxième fenêtre est déjà ouverte
    if deuxieme_fenetre is not None and deuxieme_fenetre.winfo_exists():
        deuxieme_fenetre.deiconify()
        return

    deuxieme_fenetre = tk.Toplevel(fenetre)
    deuxieme_fenetre.title("Gestion des clés publiques RSA")
    deuxieme_fenetre.iconbitmap("logo3RSAl - Copie.ico")
    frame_ajout = tk.Frame(deuxieme_fenetre)
    frame_ajout.grid(pady=10)

    label_nom = tk.Label(frame_ajout, text="Nom :")
    label_nom.grid(row=0, column=0, padx=10)
    entry_nom = tk.Entry(frame_ajout)
    entry_nom.grid(row=0, column=1, padx=10)

    label_publique = tk.Label(frame_ajout, text="Clé publique :")
    label_publique.grid(row=1, column=0, padx=10)
    entry_publique = tk.Entry(frame_ajout)
    entry_publique.grid(row=1, column=1, padx=10)

    button_ajouter = tk.Button(frame_ajout, text="Ajouter", command=ajouter_cle)
    button_ajouter.grid(row=2, columnspan=2, pady=10)

    frame_cles = tk.Frame(deuxieme_fenetre)
    frame_cles.grid(pady=10)

    charger_registre()
    label_aver = tk.Label(deuxieme_fenetre,
                          text="Le meilleur moyen de stocker vos clés publiques reste le papier!  ;) ",
                          font=("Helvetica", 10))
    label_aver.grid()


deuxieme_fenetre = None


def supprimer():
    fenetre.withdraw()  # Masquer temporairement la fenêtre principale
    # Ajoutez ici le code de suppression
    fenetre.deiconify()


def generate_keys():
    if cle == 2:
        p = random.randint(10000000000000, 99999999999999)
        q = random.randint(10000000000000, 99999999999999)
        while not is_prime(p):
            p += 1
        while not is_prime(q):
            q += 1
        n = p * q
        phi = (p - 1) * (q - 1)
        e = random.randint(2, phi - 1)
        while gcd(e, phi) != 1:
            e += 1
        d = modinv(e, phi)
        return (e, n), (d, n)
    else:
        p = random.randint(100000000, 999999999)
        q = random.randint(100000000, 999999999)
        while not is_prime(p):
            p += 1
        while not is_prime(q):
            q += 1
        n = p * q
        phi = (p - 1) * (q - 1)
        e = random.randint(2, phi - 1)
        while gcd(e, phi) != 1:
            e += 1
        d = modinv(e, phi)
        return (e, n), (d, n)


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True


def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a


def modinv(a, m):
    g, x, y = gcd(a, m), 0, 1
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return pow(a, -1, m)


def encrypt(message, public_key):
    if public_key:
        e, n = public_key
        return [pow(ord(c), e, n) for c in message]
    else:
        messagebox.showerror("Erreur", "veuillez entrez une clé publique.")
        return


def encryptprivee(message, public_key):
    if public_key:
        e, n = public_key
        return [pow(ord(c), e, n) for c in message]


def decrypt(cle_hex, cle_privee):
    d, n = cle_privee
    encrypted_values = cle_hex.split()
    decrypted_chars = [chr(pow(int(c), d, n) % 256) for c in encrypted_values]
    return ''.join(decrypted_chars)


def crypter(cle_hex):
    cle_publique = tuple(map(int, champ_clepublique.get().split()))
    cle_privee = tuple(map(int, champ_clepriver.get().split()))
    message = champ_message.get("1.0", tk.END).strip()
    cle_hex1 = encrypt(cle_hex, cle_publique)
    cle_hex1_str = " ".join(
        str(x) for x in cle_hex1)  # Convertir les éléments de la liste en chaînes de caractères et les concaténer
    return cle_hex1_str


def decrypter(cle_hex):
    cle_privee = tuple(map(int, champ_clepriver.get().split()))
    cle_hex = decrypt(cle_hex, cle_privee)
    return cle_hex


def calculate_sha256_hash(text):
    sha256_hash = hashlib.sha256()
    sha256_hash.update(text.encode('utf-8'))
    return sha256_hash.hexdigest()


def open_key_management_window():
    global key_management_window

    if key_management_window is not None:
        key_management_window.deiconify()
        return

    key_management_window = tk.Toplevel(fenetre)
    key_management_window.title("Gestion des clés")

    def on_key_management_window_close():
        global key_management_window
        key_management_window.destroy()
        key_management_window = None

    key_management_window.iconbitmap("logo3RSAl - Copie.ico")
    key_management_window.protocol("WM_DELETE_WINDOW", on_key_management_window_close)

    label_clepublique = tk.Label(key_management_window, text="Clé publique:", font=("Helvetica", 12))
    label_clepublique.grid(padx=170)
    champ_clepublique = tk.Entry(key_management_window, width=60)
    champ_clepublique.grid()

    label_clepriver = tk.Label(key_management_window, text="Clé privée:", font=("Helvetica", 12))
    label_clepriver.grid()
    champ_clepriver = tk.Entry(key_management_window, width=60)
    champ_clepriver.grid()

    label_password = tk.Label(key_management_window, text="Mot de passe:", font=("Helvetica", 12))
    label_password.grid()
    champ_password = tk.Entry(key_management_window, width=50, show="*")
    champ_password.grid()

    def generate_key_pair():
        public_key, private_key = generate_keys()
        champ_clepublique.delete(0, tk.END)
        champ_clepriver.delete(0, tk.END)
        champ_clepublique.insert(tk.END, " ".join(str(x) for x in public_key))
        champ_clepriver.insert(tk.END, " ".join(str(x) for x in private_key))

    bouton_generer = tk.Button(key_management_window, text="Générer une nouvelle paire de clés",
                               command=generate_key_pair)
    bouton_generer.grid()

    def save_key_pair():
        public_key = champ_clepublique.get().strip()
        private_key = champ_clepriver.get().strip()
        password = champ_password.get().strip()

        if public_key and private_key and password:
            # Conversion du mot de passe en une clé de 32 octets
            key = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), b'salt', 100000)

            # Encodage de la clé en base64
            encoded_key = base64.urlsafe_b64encode(key)

            # Création de l'objet Fernet avec la clé encodée
            cipher_suite = Fernet(encoded_key)

            # Chiffrement de la paire de clés avec la clé
            encrypted_public_key = cipher_suite.encrypt(public_key.encode('utf-8'))
            encrypted_private_key = cipher_suite.encrypt(private_key.encode('utf-8'))

            key_pair = f"Clé publique: {encrypted_public_key.decode('utf-8')}\nClé privée: {encrypted_private_key.decode('utf-8')}"
            with open("gestion.txt", "w") as file:
                file.write(key_pair)
                messagebox.showinfo("Sauvegarde", "La paire de clés a été enregistrée avec succès.")
        else:
            messagebox.showerror("Erreur", "Veuillez remplir tous les champs.")

    bouton_enregistrer = tk.Button(key_management_window, text="Enregistrer", command=save_key_pair)
    bouton_enregistrer.grid()

    label_aver2 = tk.Label(key_management_window, text="Le meilleur moyen de stocker vos clés reste le papier!  ;) ",
                           font=("Helvetica", 10))
    label_aver2.grid(pady=1)


def destroy_key_management_window():
    global key_management_window

    if key_management_window is not None:
        key_management_window.withdraw()


def destroy_key_access_window():
    global key_access_window

    if key_access_window is not None:
        key_access_window.withdraw()


def copy_result():
    result = champ_message.get("1.0", tk.END)
    if result:
        pyperclip.copy(result)


def encryptaes(message, key):
    backend = default_backend()
    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)
    encryptor = cipher.encryptor()
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(message.encode()) + padder.finalize()
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()
    return iv + ciphertext


def decryptaes(ciphertext, key):
    backend = default_backend()
    iv = ciphertext[:16]
    ciphertext = ciphertext[16:]
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)
    decryptor = cipher.decryptor()
    unpadder = padding.PKCS7(128).unpadder()
    decrypted_data = decryptor.update(ciphertext) + decryptor.finalize()
    message = unpadder.update(decrypted_data) + unpadder.finalize()
    return message.decode()


def update_label():
    label_typechiffrage2.config(text=type2.get())


def type_chiffrage():
    global type
    global type2
    if type == 1:
        type = 2
        type2.set("RSA")
        label_typechiffrage2.config(text=type2.get())
    elif type != 1:
        type = 1
        type2.set("AES+RSA")
        label_typechiffrage2.config(text=type2.get())


def type_signature():
    global sign
    global sign2
    if sign == 1:
        sign = 2
        sign2.set("Désactiver")
        label_typechiffrage2.config(text=sign2.get())
        global cle_visible2
        cle_visible2 = not cle_visible2
        if cle_visible2:
            label_clepriver.grid(row=0, column=4)
            champ_clepriver.grid(row=1, column=4)

        else:
            label_clepriver.grid_forget()
            champ_clepriver.grid_forget()
    elif sign != 1:
        sign = 1
        sign2.set("Activer")
        label_typechiffrage2.config(text=sign2.get())

        cle_visible2 = not cle_visible2
        if cle_visible2:
            label_clepriver.grid(row=0, column=4)
            champ_clepriver.grid(row=1, column=4)

        else:
            label_clepriver.grid_forget()
            champ_clepriver.grid_forget()


def crypteraes():
    if type == 1:
        # Récupérer la clé
        cle_hex = champ_cle.get()
        cle = bytes.fromhex(cle_hex)
        # Récupérer le message à crypter
        message = champ_message.get("1.0", tk.END).strip()  # Récupérer le texte depuis le widget Text
        data = message
        hasher = hashes.Hash(hashes.SHA256(), backend=default_backend())
        hasher.update(data.encode('utf-8'))
        hash_value = hasher.finalize()
        if sign == 1:
            print(hash_value.hex())
            hashmessage = hash_value.hex()
            print(hashmessage)
            cle_publique = tuple(map(int, champ_clepublique.get().split()))
            cle_privee = tuple(map(int, champ_clepriver.get().split()))

            cle_hex1 = encryptprivee(hashmessage, cle_privee)
            cle_hex1_str = " ".join(str(x) for x in
                                    cle_hex1)  # Convertir les éléments de la liste en chaînes de caractères et les concaténer
            print(cle_hex1_str)

            # Ajouter "Start AES key", la clé AES en hexadécimal et "End AES key" avant et après le message chiffré
            cle_hex1_str = cle_hex1_str
            cle_hex = crypter(cle_hex)
            ciphertext = encryptaes(message, cle)
            ciphertext_with_key = f"---Start Signature---\n{cle_hex1_str}\n---End Signature---\n" \
                                  f"---Start AES key---\n{cle_hex}\n---End AES key---\n{ciphertext.hex()}"
            # Afficher le texte chiffré
            champ_message.delete('1.0', tk.END)
            champ_message.insert(tk.END, ciphertext_with_key)

        if sign != 1:
            # Ajouter "Start AES key", la clé AES en hexadécimal et "End AES key" avant et après le message chiffré

            cle_hex = crypter(cle_hex)
            ciphertext = encryptaes(message, cle)
            ciphertext_with_key = f"---Start AES key---\n{cle_hex}\n---End AES key---\n{ciphertext.hex()}"
            # Afficher le texte chiffré
            champ_message.delete('1.0', tk.END)
            champ_message.insert(tk.END, ciphertext_with_key)

    else:
        message = champ_message.get("1.0", tk.END).strip()  # Récupérer le texte depuis le widget Text
        data = message
        hasher = hashes.Hash(hashes.SHA256(), backend=default_backend())
        hasher.update(data.encode('utf-8'))
        hash_value = hasher.finalize()
        if sign == 1:
            print(hash_value.hex())
            hashmessage = hash_value.hex()
            print(hashmessage)
            cle_publique = tuple(map(int, champ_clepublique.get().split()))
            cle_privee = tuple(map(int, champ_clepriver.get().split()))

            cle_hex1 = encryptprivee(hashmessage, cle_privee)
            cle_hex1_str = " ".join(str(x) for x in
                                    cle_hex1)  # Convertir les éléments de la liste en chaînes de caractères et les concaténer
            print(cle_hex1_str)

            # Ajouter "Start AES key", la clé AES en hexadécimal et "End AES key" avant et après le message chiffré
            cle_hex1_str = cle_hex1_str

            ciphertext = crypter(message)
            ciphertext_with_key = f"---Start Signature---\n{cle_hex1_str}\n---End Signature---\n{ciphertext}"
            # Afficher le texte chiffré
            champ_message.delete('1.0', tk.END)
            champ_message.insert(tk.END, ciphertext_with_key)
        else:
            cle_publique = tuple(map(int, champ_clepublique.get().split()))
            cle_privee = tuple(map(int, champ_clepriver.get().split()))
            message = champ_message.get("1.0", tk.END).strip()
            ciphertext = encrypt(message, cle_publique)

            champ_message.delete('1.0', tk.END)
            champ_message.insert('1.0', " ".join(str(x) for x in ciphertext))



# Fonction pour décrypter le message
def decrypteraes():
    if type == 1:
        # Récupérer le texte chiffré
        ciphertext_with_key = champ_message.get('1.0', tk.END).strip()
        # Extraire la clé et le message chiffré
        start_marker = "---Start AES key---"
        end_marker = "---End AES key---"
        if start_marker not in ciphertext_with_key or end_marker not in ciphertext_with_key:
            messagebox.showerror("Erreur", "Clé AES manquante dans le texte chiffré, ou clé priver manquante.")
            return
        start_index = ciphertext_with_key.index(start_marker) + len(start_marker)
        end_index = ciphertext_with_key.index(end_marker)
        cle_hex = ciphertext_with_key[start_index:end_index].strip()
        cle_hex = decrypter(cle_hex)
        message_hex = ciphertext_with_key[end_index + len(end_marker):].strip()

        # Convertir la clé et le message hexadécimaux en chaînes d'octets (bytes)
        cle = bytes.fromhex(cle_hex)
        message = bytes.fromhex(message_hex)
        # Appeler la fonction decrypt() pour décrypter le message
        plaintext = decryptaes(message, cle)
        # Afficher le message décrypté
        champ_message.delete('1.0', tk.END)
        champ_message.insert(tk.END, plaintext)
        message = champ_message.get("1.0", tk.END).strip()  # Récupérer le texte depuis le widget Text
        data = message
        hasher = hashes.Hash(hashes.SHA256(), backend=default_backend())
        hasher.update(data.encode('utf-8'))
        hash_value = hasher.finalize()

        print(hash_value.hex())
        hashmessage = hash_value.hex()
        print(hashmessage)

        cle_publique = tuple(map(int, champ_clepublique.get().split()))
        cle_privee = tuple(map(int, champ_clepriver.get().split()))

        if sign == 1:
            start_marker = "---Start Signature---"
            end_marker = "---End Signature---"
            start_index = ciphertext_with_key.index(start_marker) + len(start_marker)
            end_index = ciphertext_with_key.index(end_marker)
            cle_sign = ciphertext_with_key[start_index:end_index].strip()

            cle_publique = tuple(map(int, champ_clepublique.get().split()))
            sha256dechiffre = decrypt(cle_sign, cle_publique)

            if sha256dechiffre == hashmessage:
                cle_publique = str(cle_publique)
                messagebox.showinfo("Signature vérifié", "L'auteur de se message est:" + cle_publique)
            else:
                messagebox.showwarning("Signature non valide ou manquante",
                                       "Vous ne pouvez pas être sûr de qui à écrit se message. ")

    else:
        message = champ_message.get("1.0", tk.END).strip()  # Récupérer le texte depuis le widget Text
        data = message
        hasher = hashes.Hash(hashes.SHA256(), backend=default_backend())
        hasher.update(data.encode('utf-8'))
        hash_value = hasher.finalize()

        print(hash_value.hex())
        hashmessage = hash_value.hex()
        print(hashmessage)
        ciphertext_with_key = champ_message.get('1.0', tk.END).strip()

        if sign == 1:
            cle_publique = tuple(map(int, champ_clepublique.get().split()))
            ciphertext_with_key = champ_message.get("1.0", tk.END).strip()
            start_marker = "---Start Signature---"
            end_marker = "---End Signature---"
            start_index = ciphertext_with_key.index(start_marker) + len(start_marker)
            end_index = ciphertext_with_key.index(end_marker)
            cle_sign = ciphertext_with_key[start_index:end_index].strip()
            cle_sign = decrypt(cle_sign,cle_publique)
            message_hex = ciphertext_with_key[end_index + len(end_marker):].strip()
            cle_privee = tuple(map(int, champ_clepriver.get().split()))

            message = decrypt(message_hex, cle_privee)

            data = message
            hasher = hashes.Hash(hashes.SHA256(), backend=default_backend())
            hasher.update(data.encode('utf-8'))
            hash_value = hasher.finalize()

            print(hash_value.hex())
            hashmessage = hash_value.hex()
            print(hashmessage)
            sha256dechiffre = cle_sign

            champ_message.delete("1.0", tk.END)
            champ_message.insert(tk.END, message)

            if sha256dechiffre == hashmessage:
                cle_publique = str(cle_publique)
                messagebox.showinfo("Signature vérifié", "L'auteur de se message est:" + cle_publique)
            else:
                messagebox.showwarning("Signature non valide ou manquante",
                                       "Vous ne pouvez pas être sur de qui à écrit se message. ")
            print(sha256dechiffre)
            print(hashmessage)
        else:

            cle_publique = tuple(map(int, champ_clepublique.get().split()))
            cle_privee = tuple(map(int, champ_clepriver.get().split()))
            ciphertext = champ_message.get("1.0", tk.END).strip()
            message = decrypt(ciphertext, cle_privee)
            champ_message.delete("1.0", tk.END)
            champ_message.insert(tk.END, message)


def generate_and_display_aes_key():
    key = generate_aes_key()
    champ_cle.delete(0, tk.END)
    champ_cle.insert(0, key.hex())


def copieraes(texte):
    fenetre.clipboard_clear()
    fenetre.clipboard_append(texte)




def open_key_access_window():
    global key_access_window

    if key_access_window is not None:
        key_access_window.deiconify()
        return

    key_access_window = tk.Toplevel(fenetre)
    key_access_window.title("Accès à la clé privée")
    key_access_window.iconbitmap("logo3RSAl - Copie.ico")

    def on_key_access_window_close():
        global key_access_window
        key_access_window.destroy()
        key_access_window = None

    key_access_window.protocol("WM_DELETE_WINDOW", on_key_access_window_close)

    label_password = tk.Label(key_access_window, text="Mot de passe:", font=("Helvetica", 12))
    label_password.grid(padx=120)
    champ_password = tk.Entry(key_access_window, width=50, show="*")
    champ_password.grid()

    def access_key_pair():
        password = champ_password.get().strip()

        # Conversion du mot de passe en une clé de 32 octets
        key = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), b'salt', 100000)

        # Encodage de la clé en base64
        encoded_key = base64.urlsafe_b64encode(key)

        # Création de l'objet Fernet avec la clé encodée
        cipher_suite = Fernet(encoded_key)

        with open("gestion.txt", "r") as file:
            stored_key_pair = file.read().strip().split('\n')

            # Décryptage de la paire de clés avec la clé
            decrypted_public_key = cipher_suite.decrypt(stored_key_pair[0].split(': ')[1].encode('utf-8')).decode(
                'utf-8')
            decrypted_private_key = cipher_suite.decrypt(stored_key_pair[1].split(': ')[1].encode('utf-8')).decode(
                'utf-8')


            champ_clepriver.delete(0, tk.END)

            champ_clepriver.insert(tk.END, decrypted_private_key)

            messagebox.showinfo("Accès autorisé", "Accès à la clé privée autorisé.")

        on_key_access_window_close()

    bouton_access = tk.Button(key_access_window, text="Accéder", command=access_key_pair)
    bouton_access.grid()

def open_key_access_window2():
    global key_access_window

    if key_access_window is not None:
        key_access_window.deiconify()
        return

    key_access_window = tk.Toplevel(fenetre)
    key_access_window.title("Accès à la clé publique")
    key_access_window.iconbitmap("logo3RSAl - Copie.ico")

    def on_key_access_window_close():
        global key_access_window
        key_access_window.destroy()
        key_access_window = None

    key_access_window.protocol("WM_DELETE_WINDOW", on_key_access_window_close)

    label_password = tk.Label(key_access_window, text="Mot de passe:", font=("Helvetica", 12))
    label_password.grid(padx=120)
    champ_password = tk.Entry(key_access_window, width=50, show="*")
    champ_password.grid()

    def access_key_pair():
        password = champ_password.get().strip()

        # Conversion du mot de passe en une clé de 32 octets
        key = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), b'salt', 100000)

        # Encodage de la clé en base64
        encoded_key = base64.urlsafe_b64encode(key)

        # Création de l'objet Fernet avec la clé encodée
        cipher_suite = Fernet(encoded_key)

        with open("gestion.txt", "r") as file:
            stored_key_pair = file.read().strip().split('\n')

            # Décryptage de la paire de clés avec la clé
            decrypted_public_key = cipher_suite.decrypt(stored_key_pair[0].split(': ')[1].encode('utf-8')).decode(
                'utf-8')
            decrypted_private_key = cipher_suite.decrypt(stored_key_pair[1].split(': ')[1].encode('utf-8')).decode(
                'utf-8')



            champ_clepublique.delete(0, tk.END)

            champ_clepublique.insert(tk.END, decrypted_public_key)
            messagebox.showinfo("Accès autorisé", "Accès à la clé publique autorisé.")

        on_key_access_window_close()

    bouton_access = tk.Button(key_access_window, text="Accéder", command=access_key_pair)
    bouton_access.grid()

def open_key_access_window3():
    global key_access_window

    if key_access_window is not None:
        key_access_window.deiconify()
        return

    key_access_window = tk.Toplevel(fenetre)
    key_access_window.title("Accès à la paire de clé")
    key_access_window.iconbitmap("logo3RSAl - Copie.ico")

    def on_key_access_window_close():
        global key_access_window
        key_access_window.destroy()
        key_access_window = None

    key_access_window.protocol("WM_DELETE_WINDOW", on_key_access_window_close)

    label_password = tk.Label(key_access_window, text="Mot de passe:", font=("Helvetica", 12))
    label_password.grid(padx=120)
    champ_password = tk.Entry(key_access_window, width=50, show="*")
    champ_password.grid()

    def access_key_pair():
        password = champ_password.get().strip()

        # Conversion du mot de passe en une clé de 32 octets
        key = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), b'salt', 100000)

        # Encodage de la clé en base64
        encoded_key = base64.urlsafe_b64encode(key)

        # Création de l'objet Fernet avec la clé encodée
        cipher_suite = Fernet(encoded_key)

        with open("gestion.txt", "r") as file:
            stored_key_pair = file.read().strip().split('\n')

            # Décryptage de la paire de clés avec la clé
            decrypted_public_key = cipher_suite.decrypt(stored_key_pair[0].split(': ')[1].encode('utf-8')).decode(
                'utf-8')
            decrypted_private_key = cipher_suite.decrypt(stored_key_pair[1].split(': ')[1].encode('utf-8')).decode(
                'utf-8')


            champ_clepriver.delete(0, tk.END)
            champ_clepublique.delete(0, tk.END)
            champ_clepriver.insert(tk.END, decrypted_private_key)
            champ_clepublique.insert(tk.END, decrypted_public_key)
            messagebox.showinfo("Accès autorisé", "Accès à la paire de clé autorisé.")

        on_key_access_window_close()

    bouton_access = tk.Button(key_access_window, text="Accéder", command=access_key_pair)
    bouton_access.grid()


fenetre = tk.Tk()
fenetre.state('zoomed')
fenetre.title("CRRO")
fenetre.iconbitmap("logo3RSAl - Copie.ico")
menubar = tk.Menu(fenetre)
fenetre.config(menu=menubar)
type2 = tk.StringVar()
type2.set("AES+RSA")
sign2 = tk.StringVar()
sign2.set("Désactiver")

# Création du menu "Fichier"
file_menu = tk.Menu(menubar, tearoff=False)
menubar.add_cascade(label="Fichier", menu=file_menu)
file_menu.add_command(label="Nouvelles paire de clé", command=open_key_management_window)
file_menu.add_command(label="Accées à la paire de clé", command=open_key_access_window3)
file_menu.add_command(label="Partager/accéder clé publique ", command=open_key_access_window2)
file_menu.add_command(label="Accéder à la clé privée", command=open_key_access_window)
file_menu.add_command(label="Copier bloc note", command=copy_result)
file_menu.add_command(label="Chiffrer/déchiffrer fichiers", command=ouvrir_file)
file_menu.add_separator()
file_menu.add_command(label="Quitter", command=fenetre.quit)

# Création du menu "Chiffrement"
encrypt_menu = tk.Menu(menubar, tearoff=False)
menubar.add_cascade(label="Chiffrement", menu=encrypt_menu)
encrypt_menu.add_command(label="Chiffrer bloc note", command=crypteraes)
encrypt_menu.add_command(label="Déchiffrer bloc note", command=decrypteraes)
encrypt_menu.add_command(label="Chiffrer/dechiffrer fichiers", command=ouvrir_file)

cle_menu = tk.Menu(menubar, tearoff=False)
menubar.add_cascade(label="gestion des clés", menu=cle_menu)
cle_menu.add_command(label="Nouvelles paire de clé", command=open_key_management_window)
cle_menu.add_command(label="regsitre clé publique", command=ouvrir_deuxieme_fenetre)
cle_menu.add_command(label="Accées à la paire de clé", command=open_key_access_window3)
cle_menu.add_command(label="Partager/accéder clé publique ", command=open_key_access_window2)
cle_menu.add_command(label="Accès clé privée", command=open_key_access_window)

cle_menu.add_command(label="Type de clé", command=ouvrir_parametres2)

parametres_menu = tk.Menu(menubar, tearoff=False)
menubar.add_cascade(label="paramètres", menu=parametres_menu)
parametres_menu.add_command(label="Taille du champ", command=ouvrir_parametres)
parametres_menu.add_command(label="Type de clé", command=ouvrir_parametres2)
parametres_menu.add_command(label="Afficher/cacher clé AES", command=toggle_key_visibility)
parametres_menu.add_command(label="Afficher/cacher clé priver", command=toggle_key_visibility2)
parametres_menu.add_command(label="Chiffrage AES+RSA/RSA", command=type_chiffrage)
parametres_menu.add_command(label="Signature Désactiver/Activer", command=type_signature)

apropos_menu = tk.Menu(menubar, tearoff=False)
menubar.add_cascade(label="à propos", menu=apropos_menu)
apropos_menu.add_command(label="Version : 2.7.3 ")
apropos_menu.add_command(label="Notre site : crro.neocities.org")

frame = tk.Frame(fenetre)
frame.grid(row=0, column=0, padx=10, pady=10, sticky=tk.W)

bouton_crypter = tk.Button(frame, text="Chiffrer", width=8, height=2, relief="groove", command=crypteraes)
bouton_crypter.grid(row=0, column=0, padx=2.5)
bouton_crypter = tk.Button(frame, text="Déchiffrer", width=8, height=2, relief="groove", command=decrypteraes)
bouton_crypter.grid(row=0, column=1, padx=10, sticky="ne")

label_typechiffrage = tk.Label(frame, text="Type de chiffrage:", font=("Helvetica", 8))
label_typechiffrage.grid(row=1, column=0, padx=1, sticky="ne")
label_typechiffrage2 = tk.Label(frame, textvariable=type2)
label_typechiffrage2.grid(row=2, column=0, padx=1)
label_typechiffrage = tk.Label(frame, text="Type de chiffrage:", font=("Helvetica", 8))
label_typechiffrage.grid(row=1, column=0, padx=1, sticky="ne")
label_typechiffrage2 = tk.Label(frame, textvariable=type2)
label_typechiffrage2.grid(row=2, column=0, padx=1)

label_signature = tk.Label(frame, text="Signature:", font=("Helvetica", 8))
label_signature.grid(row=1, column=1, padx=1)
label_signature2 = tk.Label(frame, textvariable=sign2)
label_signature2.grid(row=2, column=1, padx=1)
label_clepublique = tk.Label(frame, text="Clé publique :", font=("Helvetica", 12))
label_clepublique.grid(row=0, column=3, padx=10)
champ_clepublique = tk.Entry(frame, width=60)
champ_clepublique.grid(row=1, column=3, padx=10)

label_clepriver = tk.Label(frame, text="Clé privée:", font=("Helvetica", 12))
label_clepriver.grid(row=0, column=4)
label_clepriver.grid_forget()
champ_clepriver = tk.Entry(frame, width=60)
champ_clepriver.grid(row=1, column=4)
champ_clepriver.grid_forget()

label_cle = tk.Label(frame, text="Clé (hexadécimal) : "
                     , font=("Helvetica", 12))
label_cle.grid(row=0, column=5)
label_cle.grid_forget()

champ_cle = tk.Entry(frame, width=50)
champ_cle.grid(row=1, column=5, padx=5)
champ_cle.grid_forget()
bouton_generer_cle_aes = tk.Button(frame, text="Générer nouvelle clé AES 256 bits",
                                   command=generate_and_display_aes_key)
bouton_generer_cle_aes.grid(row=2, column=5)
bouton_generer_cle_aes.grid_forget()
key = generate_aes_key()
champ_cle.delete(0, tk.END)
champ_cle.insert(0, key.hex())
label_message = tk.Label(frame, text="Bloc note:", font=("Helvetica", 12))
label_message.grid(row=4, column=0)
champ_message = tk.Text(fenetre, height=5, width=5)
champ_message.config(height=30, width=150, padx=10, bd=1, relief="solid", highlightbackground="light blue"
                     , highlightcolor="light blue")
champ_message.grid(row=5, column=0, padx=15)

fenetre.mainloop()
